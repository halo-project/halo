syntax = "proto3";

package halo.pb;

///////////////////// Data definitions ///////////////////////

enum FunctionState {
  UNPATCHED = 0;
  REDIRECTED = 1;
  BAKEOFF = 2;
}

// Process-side information about a function in memory.
message FunctionInfo {
  string label = 1;
  uint32 size = 2;
  uint64 start = 3;
  bool patchable = 4;
}

// information about the AOT-compiled binary executable
// corresponding to the client process.
message ModuleInfo {
  string obj_path = 1;
  uint64 vma_start = 2;
  uint64 vma_end = 3;
  uint64 vma_delta = 4;
  repeated string build_flags = 5;
  repeated FunctionInfo funcs = 6;

  // TODO: a SHA hash of the bitcode would be nice. This way
  // the server can ask for the bitcode if it doesn't already have it.
  bytes bitcode = 7;
}

// branch-target buffer info from perf
message BranchInfo {
  uint64 from = 1;
  uint64 to = 2;
  bool mispred = 3;
  bool predicted = 4;
}

// summary statistics for some metric / measure
message SummaryStats {
  uint32 samples = 1;
  double mean = 2;
  double population_variance = 3;
  double variance = 4;
  double deviation = 5;
  double error_pct = 6;
}

message FunctionAddress {
  uint64 func_addr = 1; // absolute address in client's addr space
}

// for a symbol within an unlinked dylib
message LibFunctionSymbol {
  string label = 1;
  bool externally_visible = 2; // TODO: is this actually needed / used?
}

////////////////////////////////////////////////////////////////



//////////////////////  Message Definitions  ///////////////////


///////////////////// Client -> Server /////////////////////////


// First message expected by the server upon connection with information about
// the client.
message ClientEnroll {
  string process_triple = 1;
  string host_cpu = 2;
  ModuleInfo module = 3;
}

message RawSample {
  uint64 instr_ptr = 1;
  uint32 thread_id = 2;
  uint64 time = 3;
  uint64 weight = 4;
  repeated uint64 call_context = 5;
  repeated BranchInfo branch = 6;
}

message FunctionData {
  uint64 calls = 1;
  SummaryStats call_frequency = 2;
}

message ThreadData {
  uint64 total_calls = 1;
  SummaryStats total_call_frequency = 2;
  map<uint64, FunctionData> func_data = 3;
}

message XRayProfileData {
  uint64 total_events = 1;
  map<uint64, ThreadData> thread_data = 2;
}

message DyLibInfo {
  string name = 1;
  map<string,FunctionInfo> funcs = 2;
}

message BakeoffResult {
  string name = 1;
  uint64 addr = 2;
  uint64 winner = 3;
}

///////////////////// Server -> Client /////////////////////////

// tells the client to load this dylib into memory.
// no changes to the program execution occurrs otherwise.
message LoadDyLib {
  string name = 1;  // the name of the library
  repeated LibFunctionSymbol symbols = 2;
  bytes objfile = 3;
}

// tells the client that the status of the provided function's
// redirection should be changed to the provided state.
message ModifyFunction {
  string name = 1;    // not sure what we want to use this field for. perhaps name of request?
  uint64 addr = 2;
  FunctionState desired_state = 3;

  // if the function should be redirected or participate in a bake-off, which
  // other function should be used?
  // An address 0 redirection indicates that it should still execute the original code.
  uint64 other_addr = 4;
}
